# Final Solution: Unify Storage in gigi-mobile

## Problem Analysis

Currently gigi-mobile has **duplicate storage systems**:
- **Rust backend** (SQLite via gigi-store): Stores all messages, syncs offline messages, manages delivery status
- **Frontend** (localStorage + IndexedDB): Stores message history for UI, stores image Blobs

This causes:
- **Inconsistency**: Messages may exist in backend but not frontend
- **Redundant storage**: Same data stored twice
- **Sync complexity**: Need to keep both stores in sync
- **Storage waste**: Images stored as Blobs (frontend) and files (backend)

---

## Proposed Solution: Backend-First Architecture

### Architecture Overview

```
Frontend (Read-Only Cache)          Backend (Single Source of Truth)
├── Redux Store (Message Cache)    ├── SQLite Database
│   └── Messages (in-memory)       │   ├── messages table
├── Thumbnail Cache (LRU)           │   ├── offline_queue table
│   └── Thumbnails (short-lived)   │   ├── shared_files table
│                                  │   │   └── thumbnail_path
│                                  │   └── app_data table
└── LocalStorage (Metadata only)   └── File System
    ├── Chat list metadata             ├── files/
    ├── Last messages                  │   ├── Full-size downloaded files
    └── Unread counts                 └── thumbnails/
                                         └── Generated thumbnails (~10KB each)
```

### Key Principles

1. **Backend = Source of Truth**
   - All message data stored in SQLite
   - No message history in localStorage
   - Only UI metadata (chat list, unread counts) in localStorage

2. **Frontend = View Layer**
   - Redux stores only current session messages
   - Load history on-demand from backend
   - Cache active conversations

3. **Images = Backend Files + Frontend Thumbnail Cache**
   - **Full-size images**: Stored as files in `download_folder/files/`
   - **Thumbnails**: Generated by backend, stored in `download_folder/thumbnails/`
   - **Frontend cache**: Thumbnails loaded on-demand, cached in Redux (in-memory LRU)
   - **No IndexedDB**: No persistent image storage in frontend
   - **No localStorage**: No message history in localStorage

---

## Implementation Strategy

### Phase 1: Backend Enhancements

#### 1.1 Database Schema Update

Add `thumbnail_path` field to `shared_files` table:

```sql
ALTER TABLE shared_files ADD COLUMN thumbnail_path TEXT;
CREATE INDEX IF NOT EXISTS idx_shared_files_thumbnail ON shared_files(thumbnail_path);
```

Update `SharedFileInfo` structure:

```rust
pub struct SharedFileInfo {
    pub share_code: String,
    pub file_name: String,
    pub file_path: String,
    pub file_size: u64,
    pub hash: String,
    pub chunk_count: usize,
    pub thumbnail_path: Option<String>,  // New field
    pub created_at: i64,
    pub revoked: bool,
}
```

#### 1.2 Add Thumbnail Generation Utility

Create new file `gigi-store/src/thumbnail.rs`:

```rust
use image::DynamicImage;
use anyhow::Result;
use std::path::PathBuf;
use uuid::Uuid;

/// Generate thumbnail from image file
pub async fn generate_thumbnail(
    file_path: &PathBuf,
    thumbnail_dir: &PathBuf,
    max_size: (u32, u32), // (width, height)
    quality: u8, // 1-100
) -> Result<String> {
    // 1. Load image
    let img = image::open(file_path)?;
    
    // 2. Resize maintaining aspect ratio
    let thumbnail = img.thumbnail(max_size.0, max_size.1);
    
    // 3. Generate unique thumbnail filename
    let thumb_filename = format!("thumb_{}.jpg", Uuid::new_v4());
    let thumb_path = thumbnail_dir.join(&thumb_filename);
    
    // 4. Save as JPEG
    thumbnail.save(&thumb_path, image::ImageFormat::Jpeg)?;
    
    Ok(thumb_filename)
}
```

#### 1.3 Update FileSharingStore

Add methods to `gigi-store/src/file_sharing_store.rs`:

```rust
impl FileSharingStore {
    /// Update thumbnail path for a file
    pub async fn update_thumbnail_path(
        &self,
        share_code: &str,
        thumbnail_path: &str,
    ) -> Result<()> {
        use crate::entities::shared_files;
        
        let existing = shared_files::Entity::find()
            .filter(shared_files::Column::ShareCode.eq(share_code))
            .one(&self.db)
            .await?;
        
        if let Some(existing) = existing {
            let mut active_model: shared_files::ActiveModel = existing.into();
            active_model.thumbnail_path = Set(Some(thumbnail_path.to_string()));
            active_model.update(&self.db).await?;
        }
        Ok(())
    }
    
    /// Get thumbnail path by share code
    pub async fn get_thumbnail_path(&self, share_code: &str) -> Result<Option<String>> {
        use crate::entities::shared_files;
        
        let result = shared_files::Entity::find()
            .filter(shared_files::Column::ShareCode.eq(share_code))
            .one(&self.db)
            .await?;
        
        Ok(result.and_then(|r| r.thumbnail_path))
    }
}
```

#### 1.4 Add Tauri Commands

In `tauri-plugin-gigi-p2p/src/commands/messaging.rs`:

```rust
/// Get thumbnail for a shared file
#[tauri::command]
pub(crate) async fn get_file_thumbnail(
    share_code: String,
    state: State<'_, PluginState>,
) -> Result<String> {
    use base64::prelude::*;
    
    // Get thumbnail path from database
    let file_sharing_store = state.file_sharing_store.read().await;
    let store = file_sharing_store.as_ref().ok_or_else(|| {
        Error::CommandFailed("File sharing not initialized".to_string())
    })?;
    
    let thumbnail_path = store.get_thumbnail_path(&share_code).await?
        .ok_or_else(|| Error::CommandFailed("Thumbnail not found".to_string()))?;
    
    drop(file_sharing_store);
    
    // Get download directory
    let config_guard = state.config.read().await;
    let download_dir = std::path::PathBuf::from(&config_guard.download_folder);
    let thumbnail_dir = download_dir.join("thumbnails");
    let thumb_file_path = thumbnail_dir.join(&thumbnail_path);
    drop(config_guard);
    
    // Read thumbnail file
    let thumbnail_bytes = tokio::fs::read(&thumb_file_path).await
        .map_err(|e| Error::Io(format!("Failed to read thumbnail: {}", e)))?;
    
    // Convert to base64
    let base64_thumbnail = BASE64_STANDARD.encode(&thumbnail_bytes);
    
    Ok(format!("data:image/jpeg;base64,{}", base64_thumbnail))
}

/// Get full-size image for a shared file
#[tauri::command]
pub(crate) async fn get_full_image(
    share_code: String,
    state: State<'_, PluginState>,
) -> Result<String> {
    use base64::prelude::*;
    
    // Get file info from database
    let file_sharing_store = state.file_sharing_store.read().await;
    let store = file_sharing_store.as_ref().ok_or_else(|| {
        Error::CommandFailed("File sharing not initialized".to_string())
    })?;
    
    let file_info = store.get_shared_file(&share_code).await?
        .ok_or_else(|| Error::CommandFailed("File not found".to_string()))?;
    drop(file_sharing_store);
    
    // Read full image file
    let image_bytes = tokio::fs::read(&file_info.file_path).await
        .map_err(|e| Error::Io(format!("Failed to read image: {}", e)))?;
    
    // Convert to base64
    let base64_image = BASE64_STANDARD.encode(&image_bytes);
    
    Ok(format!("data:image/jpeg;base64,{}", base64_image))
}

/// Get message history from backend
#[tauri::command]
pub(crate) async fn get_messages(
    peer_id: String,
    limit: usize,
    offset: usize,
    state: State<'_, PluginState>,
) -> Result<Vec<serde_json::Value>> {
    let message_store = state.message_store.read().await;
    let store = message_store.as_ref().ok_or_else(|| {
        Error::CommandFailed("Message store not initialized".to_string())
    })?;
    drop(message_store);
    
    // Query messages from database
    // Implementation depends on MessageStore API
    Ok(vec![]) // Placeholder
}

/// Search messages
#[tauri::command]
pub(crate) async fn search_messages(
    query: String,
    peer_id: Option<String>,
    state: State<'_, PluginState>,
) -> Result<Vec<serde_json::Value>> {
    let message_store = state.message_store.read().await;
    let store = message_store.as_ref().ok_or_else(|| {
        Error::CommandFailed("Message store not initialized".to_string())
    })?;
    drop(message_store);
    
    // Search messages
    Ok(vec![]) // Placeholder
}
```

#### 1.5 Update File Sending Logic

When sending/receiving file, generate thumbnail:

```rust
// In file manager, after saving file:
if is_image_file(&file_path) {
    let config_guard = state.config.read().await;
    let download_dir = std::path::PathBuf::from(&config_guard.download_folder);
    let thumbnail_dir = download_dir.join("thumbnails");
    drop(config_guard);
    
    // Create thumbnails directory if not exists
    tokio::fs::create_dir_all(&thumbnail_dir).await?;
    
    // Generate thumbnail (200x200, quality 70)
    if let Ok(thumb_filename) = gigi_store::thumbnail::generate_thumbnail(
        &file_path,
        &thumbnail_dir,
        (200, 200),
        70,
    ).await {
        // Update database with thumbnail path
        let file_sharing_store = state.file_sharing_store.read().await;
        if let Some(store) = file_sharing_store.as_ref() {
            let _ = store.update_thumbnail_path(&share_code, &thumb_filename).await;
        }
    }
}
```

#### 1.6 Add Query & Search Features

- Add pagination to MessageStore: limit results to 50-100 messages per load
- Add filtering by date range, message type
- Add cursor-based pagination for efficient scrolling
- Emit events when new messages arrive with preview

---

### Phase 2: Frontend Refactoring

#### 2.1 Remove localStorage History & IndexedDB

- Delete `useMessagePersistence.ts` history storage
- Delete `imageStorage.ts` - remove IndexedDB usage
- Keep only metadata (chat list, unread counts) in localStorage
- Clear existing localStorage/IndexedDB on migration

#### 2.2 Update Message Type

```typescript
export interface Message {
  id: string
  from_peer_id: string
  from_nickname: string
  content: string
  timestamp: number
  isOutgoing: boolean
  isGroup?: boolean
  messageType?: 'text' | 'image' | 'file'
  shareCode?: string        // Add this
  thumbnailData?: string    // Add this for thumbnails
  imageData?: string         // Only for full image when loaded
  filename?: string
  fileSize?: number
  fileType?: string
  downloadProgress?: number
  downloadId?: string
  isDownloading?: boolean
}
```

#### 2.3 Add Backend Commands to MessagingClient

```typescript
export class MessagingClient {
  static async getMessages(peerId: string, options?: {
    limit?: number
    offset?: number
  }): Promise<Message[]> {
    const result = await GigiP2p.get_messages({
      peerId,
      limit: options?.limit || 50,
      offset: options?.offset || 0,
    })
    return JSON.parse(result)
  }
  
  static async searchMessages(query: string, peerId?: string): Promise<Message[]> {
    const result = await GigiP2p.search_messages({
      query,
      peerId: peerId || null,
    })
    return JSON.parse(result)
  }
  
  static async getFileThumbnail(shareCode: string): Promise<string> {
    return await GigiP2p.get_file_thumbnail({ shareCode })
  }
  
  static async getFullImage(shareCode: string): Promise<string> {
    return await GigiP2p.get_full_image({ shareCode })
  }
}
```

#### 2.4 Add Redux Thunks

```typescript
export const loadMessagesFromBackendAsync = createAsyncThunk(
  'chatRoom/loadMessagesFromBackend',
  async ({ peerId, limit = 50, offset = 0 }: {
    peerId: string
    limit?: number
    offset?: number
  }) => {
    const messages = await MessagingClient.getMessages(peerId, { limit, offset })
    return { messages, prepend: offset > 0 }
  }
)

export const searchMessagesAsync = createAsyncThunk(
  'chatRoom/searchMessages',
  async ({ query, peerId }: { query: string; peerId?: string }) => {
    const messages = await MessagingClient.searchMessages(query, peerId)
    return { query, peerId, messages }
  }
)

export const loadThumbnailAsync = createAsyncThunk(
  'chatRoom/loadThumbnail',
  async (shareCode: string) => {
    const thumbnail = await MessagingClient.getFileThumbnail(shareCode)
    return { shareCode, thumbnail }
  }
)

export const loadFullImageAsync = createAsyncThunk(
  'chatRoom/loadFullImage',
  async (shareCode: string) => {
    const imageData = await MessagingClient.getFullImage(shareCode)
    return { shareCode, imageData }
  }
)
```

#### 2.5 Update ChatRoom Initialization

```typescript
// When chat room opens, load messages from backend
useEffect(() => {
  if (chatId && !isLoading) {
    dispatch(loadMessagesFromBackendAsync({
      peerId: chatId,
      limit: 50,
    }))
  }
}, [chatId, isLoading, dispatch])

// When user scrolls to top, load more messages
const handleScrollToTop = () => {
  if (messages.length > 0) {
    dispatch(loadMessagesFromBackendAsync({
      peerId: chatId,
      offset: messages.length,
      limit: 50,
    }))
  }
}
```

#### 2.6 Update ImageMessageBubble

```typescript
export default function ImageMessageBubble({ message }: ImageMessageBubbleProps) {
  const dispatch = useDispatch()
  
  // Load thumbnail on mount if not available
  useEffect(() => {
    if (message.shareCode && !message.thumbnailData) {
      dispatch(loadThumbnailAsync(message.shareCode))
    }
  }, [message.shareCode, message.thumbnailData, dispatch])
  
  const handleImageClick = () => {
    if (message.shareCode && !message.imageData) {
      dispatch(loadFullImageAsync(message.shareCode))
    }
  }
  
  return (
    <div className="flex flex-col gap-2">
      {/* Thumbnail */}
      {message.thumbnailData ? (
        <img
          src={message.thumbnailData}
          alt={message.filename}
          className="max-w-xs max-h-48 rounded-lg object-cover cursor-pointer hover:opacity-90"
          onClick={handleImageClick}
        />
      ) : (
        <div className="w-full h-48 bg-gray-200 animate-pulse rounded-lg" />
      )}
      
      {/* Full Image Modal */}
      {message.imageData && (
        <ImageModal
          src={message.imageData}
          alt={message.filename}
          onClose={() => {/* clear imageData */}}
        />
      )}
      
      <p className="text-sm break-words">{message.content}</p>
    </div>
  )
}
```

#### 2.7 Add Offline Queue Status

- Show pending/sent/delivered status indicators
- Sync with backend `offline_queue` table
- Auto-retry failed sends
- Display error messages for failed deliveries

---

## Data Flow

### Sending Image Message

```
Frontend                          Backend
   |                                  |
   |-- sendFileMessage(path) --------->|
   |                                  |-- Save file to files/
   |                                  |-- Create thumbnails/ directory
   |                                  |-- Generate thumbnail (200x200, 70%)
   |                                  |-- Save thumbnail to thumbnails/
   |                                  |-- Update shared_files table
   |                                  |-- Save message to SQLite
   |                                  |-- Emit message_sent event
   |<-- { messageId, shareCode } -----|
   |                                  |
   |-- addMessageToRedux()            |
   |    (with shareCode)              |
```

### Receiving Image Message

```
Backend                          Frontend
   |                                  |
   |-- message_received event ------->|
   |    (includes shareCode)          |
   |                                  |
   |                              addMessageToRedux()
   |                              (with shareCode)
   |                                  |
   |                          [Auto-load thumbnail]
   |                                  |
   |-- get_file_thumbnail(code) ----->|
   |                                  |-- Read thumbnail file
   |                                  |-- Convert to base64
   |<-- base64 thumbnail ------------|
   |                                  |
   |                          Update Redux with thumbnail
   |                                  |
   |                          [User clicks thumbnail]
   |                                  |
   |-- get_full_image(code) ---------->|
   |                                  |-- Read full image file
   |                                  |-- Convert to base64
   |<-- base64 full image ----------|
   |                                  |
   |                          Show full image modal
```

### Loading Chat History

```
Frontend                          Backend
   |                                  |
   |-- get_messages(peerId, 50) ----->|
   |                                  |-- Query SQLite
   |<-- [messages] -------------------|
   |    (includes shareCodes)         |
   |                                  |
   addMessagesToRedux()               |
   [Auto-load thumbnails for images]   |
```

---

## Benefits

### For Thumbnail-Only Cache
1. **Reduced memory**: Thumbnails are ~10KB vs full images ~500KB-5MB
2. **Fast scrolling**: No need to load full images
3. **Better UX**: Quick preview, load detail on demand
4. **Simpler storage**: No IndexedDB complexity
5. **No persistent image data**: Clear on reload, fresh each session

### For File-Based Thumbnails
1. **No database bloat**: Thumbnails stored as files, not base64 strings
2. **Easy cleanup**: Delete files when no longer needed
3. **Better performance**: File system optimized for binary data
4. **Scalable**: Can serve thumbnails via HTTP if needed later
5. **Easy preview**: Can open thumbnails directly from file system

### Overall Benefits
1. **Single source of truth**: All data in backend, no sync issues
2. **Reduced storage**: No IndexedDB, no localStorage messages, ~100x less image data in frontend
3. **Fast UI**: Thumbnails cached in memory, quick scrolling
4. **Simpler architecture**: One storage layer to maintain
5. **Better offline sync**: Backend handles queuing automatically
6. **Cross-device consistency**: Same data everywhere

---

## Migration Considerations

### For Existing Files

For existing shared files without thumbnails:
- Generate thumbnails on-demand when first requested
- Cache generated thumbnails in `thumbnails/` directory
- Update database with `thumbnail_path`

### Cleanup Strategy

```rust
/// Clean up orphaned thumbnails
pub async fn cleanup_orphaned_thumbnails(store: &FileSharingStore, thumbnail_dir: &PathBuf) {
    let shared_files = store.list_shared_files().await.unwrap();
    let valid_thumbnails: std::collections::HashSet<String> = shared_files
        .into_iter()
        .filter_map(|f| f.thumbnail_path)
        .collect();
    
    // Delete thumbnails not in database
    let mut entries = tokio::fs::read_dir(thumbnail_dir).await.unwrap();
    while let Some(entry) = entries.next_entry().await.unwrap() {
        let filename = entry.file_name().to_string_lossy().to_string();
        if !valid_thumbnails.contains(&filename) {
            tokio::fs::remove_file(entry.path()).await.unwrap();
        }
    }
}
```

### Migration Path Options

#### Option A: Clean Break (Recommended)
- Start fresh on new version
- Clear localStorage and IndexedDB
- Show migration notice to users
- Backend already has all message data

#### Option B: Gradual Migration
1. Add feature flag for new storage
2. Load from backend if available, fallback to localStorage
3. Keep both systems during transition period
4. Remove old storage after stable

---

## Key Changes Summary

### Backend (`tauri-plugin-gigi-p2p`)
- Add `get_messages()` command with pagination
- Add `search_messages()` command
- Add `get_file_thumbnail()` command
- Add `get_full_image()` command
- Generate thumbnails for images to `thumbnails/` directory
- Add `thumbnail_path` field to `shared_files` table

### Frontend (`gigi-mobile`)
- Remove `useMessagePersistence.ts` history storage
- Remove `imageStorage.ts` IndexedDB
- Add `loadMessagesFromBackend()` thunk
- Add `loadThumbnail()` and `loadFullImage()` thunks
- Update `ImageMessageBubble` to use thumbnails
- Add full image modal component
- Add offline queue status display

---

## Expected Results

- **Single source of truth**: All data in backend
- **No duplication**: No IndexedDB, no localStorage messages
- **Fast UI**: Thumbnails cached in memory
- **Reduced storage**: ~100x less image data in frontend
- **Simpler architecture**: One storage layer to maintain
- **Better performance**: Pagination and lazy loading
- **Improved UX**: Quick previews, on-demand full images


**Next Steps (To be implemented)**

- Thumbnail Generation on File Send: Hook into file sending logic to generate thumbnails when images are shared
- Message Query Implementation: Implement actual backend message querying in get_messages() and search_messages()
- Pagination in UI: Add scroll-to-top to load more messages
- Migration UI: Create UI for users to migrate old data and see storage savings
- Cleanup: Add periodic cleanup of orphaned thumbnails